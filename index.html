<!DOCTYPE html>
<html lang = "en">
	<head>
		<title>Stéphane Petiot - Interactive Resume</title>
		<meta charset = "utf-8">
		<meta name = "viewport" content = "width = device-width, user-scalable = no, minimum-scale = 1.0, maximum-scale = 1.0">
		<link type = "text/css" rel = "stylesheet" href = "./files/CSS/main.css">
		<link rel = "icon" href = "data:,">
	</head>
	<body>
		<div id = "loader">
			<div id = "load_symbol"></div>
		</div>
		<div id = "container" style = "position : absolute; z-index : 1;"></div>
	
	<script type = 'text/javascript' src = './files/Scripts/Tween.js'></script>
	<script type = 'text/javascript' src = './files/InfoSketch.js'></script>
	<script type = 'text/javascript' src = './files/WorkExperienceSketch.js'></script>
	<script type = 'text/javascript' src = './files/EducationalBackgroundSketch.js'></script>
	<script type = 'text/javascript' src = './files/SkillsSketch.js'></script>
	<script type = 'text/javascript' src = './files/MiscellaneousSketch.js'></script>
	<script type = 'text/javascript' src = './files/LanguageHandler.js'></script>
	<script type = 'module'>

		import * as THREE from './files/Scripts/three.module.js';

		import { OrbitControls } from './files/Scripts/OrbitControls.js';

		import { EffectComposer } from './files/Scripts/EffectComposer.js';
		import { UnrealBloomPass } from './files/Scripts/UnrealBloomPass.js';
		import { RenderPass } from './files/Scripts/RenderPass.js';
		import { ShaderPass } from './files/Scripts/ShaderPass.js';
		import { ClearPass } from './files/Scripts/ClearPass.js';
		import { CopyShader } from './files/Scripts/CopyShader.js';
		import { CSS3DRenderer, CSS3DObject } from './files/Scripts/CSS3DRenderer.js';

		var rotatingGroup;
		var container;
		var particlesData = [];
		var camera, scene, renderer, composer, rayCaster, mouse;
		var positions, colors;
		var particles;
		var pointCloud;
		var particlePositions;
		var linesMesh;
		var sphereMaterial, sphereSelectedMaterial;
		var sphereWork, sphereDegree, sphereSkills, sphereMisc;
		var linesSection;
		var sectionPanel;

		var maxParticleCount = 1000;
		var particleCount = 750;
		var r = 2500;
		var rHalf = r / 2;

		var effectController = {
			showDots: true,
			showLines: true,
			minDistance: 150,
			limitConnections: true,
			maxConnections: 20,
			particleCount: 500
		};

		const SPHERE_Y_LEVELS = -500;
		
		const WORK_SECTION = 0, DEGREE_SECTION = 1, SKILLS_SECTION = 2, MISC_SECTION = 3;

		var intersectWork, intersectDegree, intersectSkills, intersectMisc;

		var cssRenderer, cssScene;

		var infoDomObject, workDomObject, degreeDomObject, skillsDomObject, miscDomObject;
		var workLabelDomObject, degreeLabelDomObject, skillsLabelDomObject, miscLabelDomObject;
		
		var frenchButton, englishButton;

		window.onload = init();
		animate();

		function init() {
			//Récupération du conteneur
			container = document.getElementById( 'container' );

			//SCENE INITIALIZATION
			//Scene
			scene = new THREE.Scene();
			cssScene = new THREE.Scene();
			//Load background texture
			const loader = new THREE.TextureLoader();
			loader.load('./files/pictures/background3.jpg' , function(texture)
			{
				scene.background = texture;
			});

			//Camera
			camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 4000 );
			camera.position.z = 1850;
			
			//Renderer
			renderer = new THREE.WebGLRenderer( { antialias: true, alpha : true } );
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize( window.innerWidth, window.innerHeight );
			
			container.appendChild( renderer.domElement );
			
			cssRenderer = new CSS3DRenderer();
			cssRenderer.setSize( window.innerWidth, window.innerHeight );
			cssRenderer.domElement.style.position = 'absolute';
			cssRenderer.domElement.style.top = 0;
			
			container.appendChild( cssRenderer.domElement );

			window.addEventListener( 'resize', onWindowResize, false );

			//Mouse Manager
			rayCaster = new THREE.Raycaster();
			mouse = new THREE.Vector2();
			
			//Controles
			var controls = new OrbitControls( camera, container );
			controls.minDistance = 1000;
			controls.maxDistance = 3000;

			//Lumières
			var light = new THREE.AmbientLight( 0xffffff , 0.6 );
			scene.add( light );

			//3D OBJECTS INITIALIZATION
			//Groupe objets orbitants
			rotatingGroup = new THREE.Group();
			scene.add( rotatingGroup );

			//Nuage de points et segments
			var segments = maxParticleCount * maxParticleCount;	//Nombre de connexions possibles
			positions = new Float32Array( segments * 3 );	//Coordonnées des points
			colors = new Float32Array( segments * 3 );	//Couleurs des points
			
			particlePositions = new Float32Array( maxParticleCount * 3 );
			particles = new THREE.BufferGeometry();

			var pMaterial = new THREE.PointsMaterial( {
				color: 0xFFFFFF,
				size: 1.1,
				blending: THREE.AdditiveBlending,
				transparent: true,
				sizeAttenuation: false
			} );

			for ( var i = 0; i < maxParticleCount; i ++ ) {
				var x = Math.random() * r - r / 2;
				var y = Math.random() * r - r / 2;
				var z = Math.random() * r - r / 2;

				particlePositions[ i * 3 ] = x;
				particlePositions[ i * 3 + 1 ] = y;
				particlePositions[ i * 3 + 2 ] = z;

				// add it to the geometry
				particlesData.push( {
					velocity: new THREE.Vector3( - 1 + Math.random() * 2, - 1 + Math.random() * 2, - 1 + Math.random() * 2 ),
					numConnections: 0
				} );
			}

			particles.setDrawRange( 0, particleCount );
			particles.setAttribute( 'position', new THREE.BufferAttribute( particlePositions, 3 ).setUsage( THREE.DynamicDrawUsage ) );

			// create the particle system
			pointCloud = new THREE.Points( particles, pMaterial );
			rotatingGroup.add( pointCloud );

			var geometry = new THREE.BufferGeometry();

			geometry.setAttribute( 'position', new THREE.BufferAttribute( positions, 3 ).setUsage( THREE.DynamicDrawUsage ) );
			geometry.setAttribute( 'color', new THREE.BufferAttribute( colors, 3 ).setUsage( THREE.DynamicDrawUsage ) );

			geometry.computeBoundingSphere();

			geometry.setDrawRange( 0, 0 );

			var material = new THREE.LineBasicMaterial( {
				vertexColors: true,
				blending: THREE.AdditiveBlending,
				transparent: true
			} );

			linesMesh = new THREE.LineSegments( geometry, material );
			rotatingGroup.add( linesMesh );

			//Spheres

			geometry = new THREE.SphereGeometry( 50, 50, 50 );
			sphereMaterial = new THREE.MeshPhongMaterial( {color : 0xffffff, transparent : true} );
			sphereSelectedMaterial = new THREE.MeshPhongMaterial({color : 0xffffff, transparent : true, opacity : 1});

			sphereWork = new THREE.Mesh( geometry, sphereMaterial );
			sphereDegree = new THREE.Mesh( geometry, sphereMaterial );
			sphereSkills = new THREE.Mesh( geometry, sphereMaterial );
			sphereMisc = new THREE.Mesh( geometry, sphereMaterial );

			sphereWork.position.set( -500, SPHERE_Y_LEVELS, 0 );
			sphereDegree.position.set( 0, SPHERE_Y_LEVELS, -500 );
			sphereSkills.position.set( 500, SPHERE_Y_LEVELS, 0 );
			sphereMisc.position.set( 0, SPHERE_Y_LEVELS, 500 );

			rotatingGroup.add( sphereWork );
			rotatingGroup.add( sphereDegree );
			rotatingGroup.add( sphereSkills );
			rotatingGroup.add( sphereMisc );

			// Lignes support section
			material = new THREE.LineBasicMaterial({ color: 0xffffff });
			geometry = new THREE.BufferGeometry().setFromPoints( 
				[
					new THREE.Vector3( 0, SPHERE_Y_LEVELS, 0 ),
					new THREE.Vector3( 0, SPHERE_Y_LEVELS / 1.5, 0 ),
					new THREE.Vector3( -850, SPHERE_Y_LEVELS / 1.5, 0 ),
					new THREE.Vector3( -900, SPHERE_Y_LEVELS / 1.5 + 50, 0 ),
					new THREE.Vector3( -850, SPHERE_Y_LEVELS / 1.5, 0 ),
					new THREE.Vector3( 850, SPHERE_Y_LEVELS / 1.5, 0 ),
					new THREE.Vector3( 900, SPHERE_Y_LEVELS / 1.5 + 50, 0 )
				]
			);
			linesSection = new THREE.Line( geometry, material );

			//Support semi-transparent section
			geometry = new THREE.ShapeBufferGeometry(new THREE.Shape(
				[
					new THREE.Vector3(-850, SPHERE_Y_LEVELS / 1.5, 0),
					new THREE.Vector3(-900, SPHERE_Y_LEVELS / 1.5 + 50, 0),
					new THREE.Vector3(-900, SPHERE_Y_LEVELS / 1.5 + 900, 0),
					new THREE.Vector3(900, SPHERE_Y_LEVELS / 1.5 + 900, 0),
					new THREE.Vector3(900, SPHERE_Y_LEVELS / 1.5 + 50, 0),
					new THREE.Vector3(850, SPHERE_Y_LEVELS / 1.5, 0),
					new THREE.Vector3(-850, SPHERE_Y_LEVELS / 1.5, 0)
				]
			));
			material = new THREE.MeshBasicMaterial({color : 0xffffff, opacity : 0.1, transparent : true});
			sectionPanel = new THREE.Mesh(geometry, material);

			// POSTPROCESSING : Effet Bloom

			var params = {
				bloomStrength: 0.75,
				bloomThreshold: 0.5,
				bloomRadius: 0.01
			};

			composer = new EffectComposer(renderer);
			composer.setSize( window.innerWidth, window.innerHeight );

			var renderPass = new RenderPass(scene, camera);

			var bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight),params.bloomStrength, params.bloomRadius, params.bloomThreshold, sphereDegree, scene, camera);
			bloomPass.threshold = params.bloomThreshold;
			bloomPass.strength = params.bloomStrength;
			bloomPass.radius = params.bloomRadius;

			composer.addPass(renderPass);
			composer.addPass(bloomPass);

			//EVENTS
			window.addEventListener('mousemove', onMouseMove, false);

			//3D HTML CONTENT
			var infoElement = document.createElement('div');

			infoElement.innerHTML = infoSketch;
			infoElement.style.position = 'absolute';
			infoElement.style.top = '5em'
			infoElement.style.width = '110em';
			infoElement.style.height = '53em';
			infoElement.style.fontFamily = 'Calibri Light, Calibri, sans-serif';

			infoDomObject = new CSS3DObject( infoElement );
			cssScene.add(infoDomObject);
			
			infoElement.getElementsByClassName('languageButton')[0].addEventListener('click', () => {
				changeLanguage( FRENCH );
				infoElement.getElementsByClassName('languageButton')[0].style.fontWeight = 'bold';
				infoElement.getElementsByClassName('languageButton')[1].style.fontWeight = 'normal';
			});
			infoElement.getElementsByClassName('languageButton')[1].addEventListener('click', () => {
				changeLanguage( ENGLISH );
				infoElement.getElementsByClassName('languageButton')[0].style.fontWeight = 'normal';
				infoElement.getElementsByClassName('languageButton')[1].style.fontWeight = 'bold';
			});

			var workElement = document.createElement( 'div' );

			workElement.innerHTML = workSketch;
			workElement.style.position = 'absolute';
			workElement.style.top = '9em'
			workElement.style.width = '110em';
			workElement.style.height = '53em';

			workDomObject = new CSS3DObject( workElement );
			workDomObject.visible = false;
			cssScene.add(workDomObject)

			var degreeElement = document.createElement( 'div' );

			degreeElement.innerHTML = degreeSketch;
			degreeElement.style.position = 'absolute';
			degreeElement.style.top = '9em'
			degreeElement.style.width = '110em';
			degreeElement.style.height = '53em';

			degreeDomObject = new CSS3DObject( degreeElement );
			degreeDomObject.visible = false;
			cssScene.add(degreeDomObject);

			var skillsElement = document.createElement( 'div' );

			skillsElement.innerHTML = skillsSketch;
			skillsElement.style.position = 'absolute';
			skillsElement.style.top = '9em'
			skillsElement.style.width = '110em';
			skillsElement.style.height = '53em';

			skillsDomObject = new CSS3DObject( skillsElement );
			skillsDomObject.visible = false;
			cssScene.add(skillsDomObject);

			var miscElement = document.createElement( 'div' );

			miscElement.innerHTML = miscSketch;
			miscElement.style.position = 'absolute';
			miscElement.style.top = '9em'
			miscElement.style.width = '110em';
			miscElement.style.height = '53em';

			miscDomObject = new CSS3DObject( miscElement );
			miscDomObject.visible = false;
			cssScene.add(miscDomObject);

			/* var workElementLabel = document.createElement( 'div' );

			workElementLabel.innerHTML += "<span id = 'workSphereLabel'>EXPERIENCE</span>";
			workElementLabel.style.fontFamily = 'Century Gothic, Calibri Light, sans-serif';
			workElementLabel.style.fontSize = '2.5em';
			workElementLabel.style.fontWeight = 'bold';

			workLabelDomObject = new CSS3DObject( workElementLabel );
			workLabelDomObject.position.set(sphereWork.position.x, SPHERE_Y_LEVELS + 125, 0);
			cssScene.add( workLabelDomObject );

			var degreeElementLabel = document.createElement( 'div' );

			degreeElementLabel.innerHTML += "<span id = 'degreeSphereLabel'>FORMATION</span>";
			degreeElementLabel.style.fontFamily = 'Century Gothic, Calibri Light, sans-serif';
			degreeElementLabel.style.fontSize = '2.5em';
			degreeElementLabel.style.fontWeight = 'bold';

			degreeLabelDomObject = new CSS3DObject( degreeElementLabel );
			degreeLabelDomObject.position.set(sphereDegree.position.x, SPHERE_Y_LEVELS + 125, 0);
			cssScene.add( degreeLabelDomObject );

			var skillsElementLabel = document.createElement( 'div' );

			skillsElementLabel.innerHTML += "<span id = 'skillsSphereLabel'>COMPETENCES</span>";
			skillsElementLabel.style.fontFamily = 'Century Gothic, Calibri Light, sans-serif';
			skillsElementLabel.style.fontSize = '2.5em';
			skillsElementLabel.style.fontWeight = 'bold';

			skillsLabelDomObject = new CSS3DObject( skillsElementLabel );
			skillsLabelDomObject.position.set(sphereSkills.position.x, SPHERE_Y_LEVELS + 125, 0);
			cssScene.add( skillsLabelDomObject );

			var miscElementLabel = document.createElement( 'div' );

			miscElementLabel.innerHTML += "<span id = 'miscSphereLabel'>DIVERS</span>";
			miscElementLabel.style.fontFamily = 'Century Gothic, Calibri Light, sans-serif';
			miscElementLabel.style.fontSize = '2.5em';
			miscElementLabel.style.fontWeight = 'bold';

			miscLabelDomObject = new CSS3DObject( miscElementLabel );
			miscLabelDomObject.position.set(sphereMisc.position.x, SPHERE_Y_LEVELS + 125, 0);
			cssScene.add( miscLabelDomObject ); */

			document.getElementById("loader").style.opacity = 0;
			setTimeout(function(){document.getElementById("loader").style.display = "none";}, 1750);
		}

		var workSelected = false;
		var degreeSelected = false;
		var skillsSelected = false;
		var miscSelected = false;
		function onMouseMove(event) {
			event.preventDefault();

			mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
			mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

			rayCaster.setFromCamera(mouse, camera);

			intersectWork = rayCaster.intersectObject(sphereWork, true);
			intersectDegree = rayCaster.intersectObject(sphereDegree, true);
			intersectSkills = rayCaster.intersectObject(sphereSkills, true);
			intersectMisc = rayCaster.intersectObject(sphereMisc, true);
			
			if (intersectWork.length > 0 && !workSelected) {
				displaySection( WORK_SECTION );
				window.removeEventListener('mousemove', onMouseMove);
				window.addEventListener('mousemove', function workLeaveWatcher(event) {
					event.preventDefault();

					mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
					mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

					rayCaster.setFromCamera(mouse, camera);

					intersectWork = rayCaster.intersectObject(sphereWork, true);

					if (intersectWork.length === 0) {
						workSelected = false;
						sphereWork.scale.set(1, 1, 1);
						sphereMaterial.opacity = 1;
						sphereWork.material = sphereMaterial;
						scene.remove(linesSection);
						scene.remove(sectionPanel);
						workDomObject.visible = false;
						cssScene.add(infoDomObject);
						cssScene.add(workLabelDomObject);
						cssScene.add(degreeLabelDomObject);
						cssScene.add(skillsLabelDomObject);
						cssScene.add(miscLabelDomObject);
						window.removeEventListener('mousemove', workLeaveWatcher)
						window.addEventListener('mousemove', onMouseMove)
					}
				});
			}
			else if (intersectDegree.length > 0 && !degreeSelected) {
				displaySection( DEGREE_SECTION );
				window.removeEventListener('mousemove', onMouseMove);
				window.addEventListener('mousemove', function degreeLeaveWatcher(event) {
					event.preventDefault();

					mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
					mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

					rayCaster.setFromCamera(mouse, camera);

					intersectDegree = rayCaster.intersectObject(sphereDegree, true);

					if (intersectDegree.length === 0) {
						degreeSelected = false;
						sphereDegree.scale.set(1, 1, 1);
						sphereMaterial.opacity = 1;
						sphereDegree.material = sphereMaterial;
						scene.remove(linesSection);
						scene.remove(sectionPanel);
						degreeDomObject.visible = false;
						cssScene.add(infoDomObject);
						cssScene.add(workLabelDomObject);
						cssScene.add(degreeLabelDomObject);
						cssScene.add(skillsLabelDomObject);
						cssScene.add(miscLabelDomObject);
						window.removeEventListener('mousemove', degreeLeaveWatcher)
						window.addEventListener('mousemove', onMouseMove)
					}
				});
			}
			else if (intersectSkills.length > 0 && !skillsSelected) {
				displaySection( SKILLS_SECTION );
				window.removeEventListener('mousemove', onMouseMove);
				window.addEventListener('mousemove', function skillsLeaveWatcher(event) {
					event.preventDefault();

					mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
					mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

					rayCaster.setFromCamera(mouse, camera);

					intersectSkills = rayCaster.intersectObject(sphereSkills, true);

					if (intersectSkills.length === 0) {
						skillsSelected = false;
						sphereSkills.scale.set(1, 1, 1);
						sphereMaterial.opacity = 1;
						sphereSkills.material = sphereMaterial;
						scene.remove(linesSection);
						scene.remove(sectionPanel);
						skillsDomObject.visible = false;
						cssScene.add(infoDomObject);
						cssScene.add(workLabelDomObject);
						cssScene.add(degreeLabelDomObject);
						cssScene.add(skillsLabelDomObject);
						cssScene.add(miscLabelDomObject);
						window.removeEventListener('mousemove', skillsLeaveWatcher)
						window.addEventListener('mousemove', onMouseMove)
					}
				});
			}
			else if (intersectMisc.length > 0 && !miscSelected) {
				displaySection( MISC_SECTION );
				window.removeEventListener('mousemove', onMouseMove);
				window.addEventListener('mousemove', function miscLeaveWatcher(event) {
					event.preventDefault();

					mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
					mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

					rayCaster.setFromCamera(mouse, camera);

					intersectMisc = rayCaster.intersectObject(sphereMisc, true);

					if (intersectMisc.length === 0) {
						miscSelected = false;
						sphereMisc.scale.set(1, 1, 1);
						sphereMaterial.opacity = 1;
						sphereMisc.material = sphereMaterial;
						scene.remove(linesSection);
						scene.remove(sectionPanel);
						miscDomObject.visible = false;
						cssScene.add(infoDomObject);
						cssScene.add(workLabelDomObject);
						cssScene.add(degreeLabelDomObject);
						cssScene.add(skillsLabelDomObject);
						cssScene.add(miscLabelDomObject);
						window.removeEventListener('mousemove', miscLeaveWatcher)
						window.addEventListener('mousemove', onMouseMove)
					}
				});
			}
		}

		function displaySection( sectionID )
		{
			sphereWork.position.y = sphereDegree.position.y = sphereSkills.position.y = sphereMisc.position.y = SPHERE_Y_LEVELS;
			var targets = [];
			switch( sectionID ) {
				case WORK_SECTION :
					workSelected = true;
					sphereWork.scale.set(1.1, 1.1, 1.1);
					sphereMaterial.opacity = 0.5;
					sphereWork.material = sphereSelectedMaterial;

					linesSection.geometry.attributes.position.array[0] = sphereWork.position.x;
					linesSection.geometry.attributes.position.array[1] = sphereWork.position.y;
					linesSection.geometry.attributes.position.array[2] = sphereWork.position.z;
					linesSection.geometry.attributes.position.needsUpdate = true;

					/* targets.push( { x : sphereWork.position.x, y : SPHERE_Y_LEVELS, z : 0 } );
					targets.push( { x : sphereDegree.position.x, y : SPHERE_Y_LEVELS / 1.5, z : 0 } );

					targets.push( { x : sphereDegree.position.x, y : SPHERE_Y_LEVELS / 1.5, z : 0 } );
					targets.push( { x : sphereWork.position.x - 100, y : SPHERE_Y_LEVELS / 1.5, z : 0 } );

					targets.push( { x : sphereDegree.position.x, y : SPHERE_Y_LEVELS / 1.5, z : 0 } );
					targets.push( { x : sphereMisc.position.x + 100, y : SPHERE_Y_LEVELS / 1.5, z : 0 } ); */
					
					workDomObject.visible = true;
					break;
				case DEGREE_SECTION :
					degreeSelected = true;
					sphereDegree.scale.set(1.1, 1.1, 1.1);
					sphereMaterial.opacity = 0.5;
					sphereDegree.material = sphereSelectedMaterial;

					linesSection.geometry.attributes.position.array[0] = sphereDegree.position.x;
					linesSection.geometry.attributes.position.array[1] = sphereDegree.position.y;
					linesSection.geometry.attributes.position.array[2] = sphereDegree.position.z;
					linesSection.geometry.attributes.position.needsUpdate = true;

					/* targets.push( { x : sphereDegree.position.x, y : SPHERE_Y_LEVELS, z : 0 } );
					targets.push( { x : sphereDegree.position.x / 2, y : SPHERE_Y_LEVELS / 1.5, z : 0 } );

					targets.push( { x : sphereDegree.position.x / 2, y : SPHERE_Y_LEVELS / 1.5, z : 0 } );
					targets.push( { x : sphereWork.position.x - 100, y : SPHERE_Y_LEVELS / 1.5, z : 0 } );

					targets.push( { x : sphereDegree.position.x / 2, y : SPHERE_Y_LEVELS / 1.5, z : 0 } );
					targets.push( { x : sphereMisc.position.x + 100, y : SPHERE_Y_LEVELS / 1.5, z : 0 } ); */
					
					degreeDomObject.visible = true;
					break;
				case SKILLS_SECTION :
					skillsSelected = true;
					sphereSkills.scale.set(1.1, 1.1, 1.1);
					sphereMaterial.opacity = 0.5;
					sphereSkills.material = sphereSelectedMaterial;

					linesSection.geometry.attributes.position.array[0] = sphereSkills.position.x;
					linesSection.geometry.attributes.position.array[1] = sphereSkills.position.y;
					linesSection.geometry.attributes.position.array[2] = sphereSkills.position.z;
					linesSection.geometry.attributes.position.needsUpdate = true;

					/* targets.push( { x : sphereSkills.position.x, y : SPHERE_Y_LEVELS , z : 0 } );
					targets.push( { x : sphereSkills.position.x / 2, y : SPHERE_Y_LEVELS / 1.5, z : 0 } );

					targets.push( { x : sphereSkills.position.x / 2, y : SPHERE_Y_LEVELS / 1.5, z : 0 } );
					targets.push( { x : sphereWork.position.x - 100, y : SPHERE_Y_LEVELS / 1.5, z : 0 } );

					targets.push( { x : sphereSkills.position.x / 2, y : SPHERE_Y_LEVELS / 1.5, z : 0 } );
					targets.push( { x : sphereMisc.position.x + 100, y : SPHERE_Y_LEVELS / 1.5, z : 0 } ); */
					
					skillsDomObject.visible = true;
					break;
				case MISC_SECTION :
					miscSelected = true;
					sphereMisc.scale.set(1.1, 1.1, 1.1);
					sphereMaterial.opacity = 0.5;
					sphereMisc.material = sphereSelectedMaterial;

					linesSection.geometry.attributes.position.array[0] = sphereMisc.position.x;
					linesSection.geometry.attributes.position.array[1] = sphereMisc.position.y;
					linesSection.geometry.attributes.position.array[2] = sphereMisc.position.z;
					linesSection.geometry.attributes.position.needsUpdate = true;

					/* targets.push( { x : sphereMisc.position.x, y : SPHERE_Y_LEVELS, z : 0 } );
					targets.push( { x : sphereSkills.position.x, y : SPHERE_Y_LEVELS / 1.5, z : 0 } );

					targets.push( { x : sphereSkills.position.x, y : SPHERE_Y_LEVELS / 1.5, z : 0 } );
					targets.push( { x : sphereWork.position.x - 100, y : SPHERE_Y_LEVELS / 1.5, z : 0 } );

					targets.push( { x : sphereSkills.position.x, y : SPHERE_Y_LEVELS / 1.5, z : 0 } );
					targets.push( { x : sphereMisc.position.x + 100, y : SPHERE_Y_LEVELS / 1.5, z : 0 } ); */
					
					miscDomObject.visible = true;
					break;
				default :
					break;
			}

			/* targets.push(
				{ x : sphereWork.position.x, y : SPHERE_Y_LEVELS / 1.5, z : 0 },
				{ x : sphereWork.position.x - 150, y : SPHERE_Y_LEVELS / 1.5 + 50, z : 0 },
				{ x : sphereMisc.position.x, y : SPHERE_Y_LEVELS / 1.5, z : 0 },
				{ x : sphereMisc.position.x + 150, y : SPHERE_Y_LEVELS / 1.5 + 50, z : 0 }
			);

			var tweens = [];
			tweens.push(new TWEEN.Tween(targets[0]).to(targets[1], 100));
			tweens.push(new TWEEN.Tween(targets[2]).to(targets[3], 100));
			tweens.push(new TWEEN.Tween(targets[4]).to(targets[5], 100));
			tweens.push(new TWEEN.Tween(targets[6]).to(targets[7], 100));
			tweens.push(new TWEEN.Tween(targets[8]).to(targets[9], 100));

			tweens[0].chain(tweens[1], tweens[2]);
			tweens[1].chain(tweens[3]);
			tweens[2].chain(tweens[4]);

			tweens[0].onUpdate(function(){
				linesSection[0].geometry.attributes.position.array[3] = targets[0].x;
				linesSection[0].geometry.attributes.position.array[4] = targets[0].y;
				
				linesSection[0].geometry.attributes.position.needsUpdate = true;
			});
			tweens[1].onUpdate(function(){
				linesSection[1].geometry.attributes.position.array[3] = targets[2].x;
				linesSection[1].geometry.attributes.position.array[4] = targets[2].y;

				linesSection[1].geometry.attributes.position.needsUpdate = true;
			});
			tweens[2].onUpdate(function(){
				linesSection[2].geometry.attributes.position.array[3] = targets[4].x;
				linesSection[2].geometry.attributes.position.array[4] = targets[4].y;
				
				linesSection[2].geometry.attributes.position.needsUpdate = true;
			});
			tweens[3].onUpdate(function(){
				linesSection[3].geometry.attributes.position.array[3] = targets[6].x;
				linesSection[3].geometry.attributes.position.array[4] = targets[6].y;
				
				linesSection[3].geometry.attributes.position.needsUpdate = true;
			});
			tweens[4].onUpdate(function(){
				linesSection[4].geometry.attributes.position.array[3] = targets[8].x;
				linesSection[4].geometry.attributes.position.array[4] = targets[8].y;
				
				linesSection[4].geometry.attributes.position.needsUpdate = true;
			});

			tweens[0].start(); */
			scene.add(linesSection);
			scene.add(sectionPanel);
			cssScene.remove(infoDomObject);
			cssScene.remove(workLabelDomObject);
			cssScene.remove(degreeLabelDomObject);
			cssScene.remove(skillsLabelDomObject);
			cssScene.remove(miscLabelDomObject);
		}

		function onWindowResize() {

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize( window.innerWidth, window.innerHeight );
			cssRenderer.setSize( window.innerWidth, window.innerHeight );
			composer.setSize( window.innerWidth, window.innerHeight );
		}

		function animate() {

			requestAnimationFrame( animate );

			var vertexpos = 0;
			var colorpos = 0;
			var numConnected = 0;

			for ( var i = 0; i < particleCount; i ++ )
				particlesData[ i ].numConnections = 0;

			for ( var i = 0; i < particleCount; i ++ ) {

				// get the particle
				var particleData = particlesData[ i ];

				particlePositions[ i * 3 ] += particleData.velocity.x;
				particlePositions[ i * 3 + 1 ] += particleData.velocity.y;
				particlePositions[ i * 3 + 2 ] += particleData.velocity.z;

				if ( particlePositions[ i * 3 + 1 ] < - rHalf || particlePositions[ i * 3 + 1 ] > rHalf )
					particleData.velocity.y = - particleData.velocity.y;

				if ( particlePositions[ i * 3 ] < - rHalf || particlePositions[ i * 3 ] > rHalf )
					particleData.velocity.x = - particleData.velocity.x;

				if ( particlePositions[ i * 3 + 2 ] < - rHalf || particlePositions[ i * 3 + 2 ] > rHalf )
					particleData.velocity.z = - particleData.velocity.z;

				if ( effectController.limitConnections && particleData.numConnections >= effectController.maxConnections )
					continue;

				// Check collision
				for ( var j = i + 1; j < particleCount; j ++ ) {

					var particleDataB = particlesData[ j ];
					if ( effectController.limitConnections && particleDataB.numConnections >= effectController.maxConnections )
						continue;

					var dx = particlePositions[ i * 3 ] - particlePositions[ j * 3 ];
					var dy = particlePositions[ i * 3 + 1 ] - particlePositions[ j * 3 + 1 ];
					var dz = particlePositions[ i * 3 + 2 ] - particlePositions[ j * 3 + 2 ];
					var dist = Math.sqrt( dx * dx + dy * dy + dz * dz );

					if ( dist < effectController.minDistance ) {

						particleData.numConnections ++;
						particleDataB.numConnections ++;

						var alpha = 1.0 - dist / effectController.minDistance;

						positions[ vertexpos ++ ] = particlePositions[ i * 3 ];
						positions[ vertexpos ++ ] = particlePositions[ i * 3 + 1 ];
						positions[ vertexpos ++ ] = particlePositions[ i * 3 + 2 ];

						positions[ vertexpos ++ ] = particlePositions[ j * 3 ];
						positions[ vertexpos ++ ] = particlePositions[ j * 3 + 1 ];
						positions[ vertexpos ++ ] = particlePositions[ j * 3 + 2 ];

						colors[ colorpos ++ ] = alpha;
						colors[ colorpos ++ ] = alpha;
						colors[ colorpos ++ ] = alpha;

						colors[ colorpos ++ ] = alpha;
						colors[ colorpos ++ ] = alpha;
						colors[ colorpos ++ ] = alpha;

						numConnected ++;
					}
				}
			}

			linesMesh.geometry.setDrawRange( 0, numConnected * 2 );
			linesMesh.geometry.attributes.position.needsUpdate = true;
			linesMesh.geometry.attributes.color.needsUpdate = true;

			pointCloud.geometry.attributes.position.needsUpdate = true;

			//TWEEN.update();

			render();
		}

		function render() {

			var time = Date.now() * 0.001;

			rotatingGroup.rotation.y = time * 0.1;

/* 			if (!(workSelected || degreeSelected || skillsSelected || miscSelected)) {
				sphereWork.position.y += Math.sin(2*time);
				sphereDegree.position.y += Math.sin(2*time);
				sphereSkills.position.y += Math.sin(2*time);
				sphereMisc.position.y += Math.sin(2*time);
			} */
			const worldPosition = new THREE.Vector3();

			if(workSelected) {
				sphereWork.getWorldPosition(worldPosition);
				linesSection.geometry.attributes.position.array[0] = worldPosition.x;
				linesSection.geometry.attributes.position.array[1] = worldPosition.y;
				linesSection.geometry.attributes.position.array[2] = worldPosition.z;
				linesSection.geometry.attributes.position.needsUpdate = true;
			} else if(degreeSelected) {
				sphereDegree.getWorldPosition(worldPosition);
				linesSection.geometry.attributes.position.array[0] = worldPosition.x;
				linesSection.geometry.attributes.position.array[1] = worldPosition.y;
				linesSection.geometry.attributes.position.array[2] = worldPosition.z;
				linesSection.geometry.attributes.position.needsUpdate = true;
			} else if(skillsSelected) {
				sphereSkills.getWorldPosition(worldPosition);
				linesSection.geometry.attributes.position.array[0] = worldPosition.x;
				linesSection.geometry.attributes.position.array[1] = worldPosition.y;
				linesSection.geometry.attributes.position.array[2] = worldPosition.z;
				linesSection.geometry.attributes.position.needsUpdate = true;
			} else if(miscSelected) {
				sphereMisc.getWorldPosition(worldPosition);
				linesSection.geometry.attributes.position.array[0] = worldPosition.x;
				linesSection.geometry.attributes.position.array[1] = worldPosition.y;
				linesSection.geometry.attributes.position.array[2] = worldPosition.z;
				linesSection.geometry.attributes.position.needsUpdate = true;
			}

			renderer.render( scene, camera );
			cssRenderer.render( cssScene, camera );
			renderer.clearDepth();
			composer.render();
		}

		</script>

	</body>
</html>